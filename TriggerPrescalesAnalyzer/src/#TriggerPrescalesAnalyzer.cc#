// -*- C++ -*-
//
// Package:    TriggerPrescalesAnalyzer
// Class:      TriggerPrescalesAnalyzer
// 
/**\class TriggerPrescalesAnalyzer TriggerPrescalesAnalyzer.cc TriggerInfoTool/TriggerPrescalesAnalyzer/src/TriggerPrescalesAnalyzer.cc
 Description: [one line class summary]
 Implementation:
     [Notes on implementation]
*/
//
// Original Author:  Edgar Carrera
//         Created:  Mon Jul  9 15:59:18 CEST 2019
// $Id$
//
//

//**

//classes to extract jet information
#include "DataFormats/JetReco/interface/PFJet.h"
#include "DataFormats/JetReco/interface/PFJetCollection.h"
#include "DataFormats/JetReco/interface/CaloJetCollection.h" 

//classes to extract trigger information
#include "DataFormats/HLTReco/interface/TriggerObject.h"
#include "DataFormats/HLTReco/interface/TriggerEvent.h"
#include "HLTrigger/HLTcore/interface/HLTConfigProvider.h"

//classes to save data
#include "TTree.h"
#include "TFile.h"
#include "TH1.h"

//class to save the histograms
#include "FWCore/ServiceRegistry/interface/Service.h"
#include "CommonTools/UtilAlgos/interface/TFileService.h"

#include<vector>

//**

// system include files
#include <memory>

// user include files
#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/EDAnalyzer.h"

#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/MakerMacros.h"

#include "FWCore/ParameterSet/interface/ParameterSet.h"

//Following the HLTEventAnalyzerAOD.h, 
//include the following headers:
#include "HLTrigger/HLTcore/interface/HLTConfigProvider.h"
#include "DataFormats/Common/interface/TriggerResults.h"
#include "DataFormats/HLTReco/interface/TriggerEvent.h"

//Also include headers from  HLTEventAnalyzerAOD.cc
#include "FWCore/Common/interface/TriggerNames.h"
#include "FWCore/Common/interface/TriggerResultsByName.h"
#include <cassert>


//
// class declaration
//

class TriggerPrescalesAnalyzer : public edm::EDAnalyzer {
   public:
      explicit TriggerPrescalesAnalyzer(const edm::ParameterSet&);
      ~TriggerPrescalesAnalyzer();

	  virtual void beginJob();
      virtual void beginRun(edm::Run const&, edm::EventSetup const&);
      virtual void analyze(const edm::Event&, const edm::EventSetup&);
	  virtual void endRun(edm::Run const&, edm::EventSetup const&);
      virtual void endJob();
      
      //the follwing are not being used here
      
      virtual void beginLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&);
      virtual void endLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&);
      static void fillDescriptions(edm::ConfigurationDescriptions& descriptions);

   private:
   
   //Methods used for the analysis
      //void analyzeJets(const edm::Event& iEvent, const edm::Handle<reco::PFJetCollection> &jets);//declare a function to do the jet analysis
      void analyzeJets(const edm::Event& iEvent, const edm::Handle<reco::CaloJetCollection> &jets);
      bool checkTriggerPass(const edm::Event& iEvent, const std::string& triggerName);//declare a function check the trigger passes
	  	    
      std::string   filterName_;//declare de filter (module) of the trigger         
      
    //declare the variables for save data in the ROOT files
	  TFile *myfile;
	  TTree *mytree;
      
   //declare histograms and variables that will go into the root files
		// ----------jet member data ---------------------------
	int numjet; //number of jets in the event
	
	TH1D *trig_vs_pt;//Histogram
    std::vector<float> jet_pt; 
    
    edm::Service<TFileService> fs;//to access the TFileService object in a framework module
     
      // from HLTEventAnalyzerAOD.h
      /// module config parameters
      edm::InputTag jetInput_;//declare the input tag for the jet collection
      std::string   processName_;
      std::string   triggerName_;
      edm::InputTag triggerResultsTag_;
      edm::InputTag triggerEventTag_;


      // additional class data memebers
      // these are actually the containers where we will store the trigger information
      edm::Handle<edm::TriggerResults>   triggerResultsHandle_;
      //edm::Handle<trigger::TriggerEvent> triggerEventHandle_;
      HLTConfigProvider hltConfig_;
      
      // ----------member data ---------------------------
};

//This should match your configuration python file
TriggerPrescalesAnalyzer::TriggerPrescalesAnalyzer(const edm::ParameterSet& iConfig):
jetInput_(iConfig.getParameter<edm::InputTag>("JetInputCollection")),
processName_(iConfig.getParameter<std::string>("processName")),
triggerName_(iConfig.getParameter<std::string>("triggerName")),
triggerResultsTag_(iConfig.getParameter<edm::InputTag>("triggerResults")),
triggerEventTag_(iConfig.getParameter<edm::InputTag>("triggerEvent"))
{
	   //now do what ever initialization is needed
	   
	   		
  using namespace std;
  using namespace edm;
	
		

	

	//this takes the type of object (input tag) specified in the configuration python file, corresponding to each container.
//https://twiki.cern.ch/twiki/bin/view/CMSPublic/SWGuideRecoDataTable
		
		
		//this take the filter (module) of the trigger	
	//filterName_ = iConfig.getParameter<std::string>("filterName");
  
  //jetInput_ = iConfig.getParameter<edm::InputTag>("JetInputCollection");
  
  //Print the configuration just to check
  cout << "Here is the information passed to the constructor:" <<endl;
  cout << "HLTEventAnalyzerAOD configuration: " << endl
       << "   Jet Input Collection = " << jetInput_.encode() << endl
       << "   ProcessName = " << processName_ << endl
       << "   TriggerName = " << triggerName_ << endl
       << "   TriggerResultsTag = " << triggerResultsTag_.encode() << endl
       << "   TriggerEventTag = " << triggerEventTag_.encode() << endl;

}


TriggerPrescalesAnalyzer::~TriggerPrescalesAnalyzer()
{
 
   // do anything here that needs to be done at desctruction time
   // (e.g. close files, deallocate resources etc.)

}

////////////member functions////////////////////////member functions////////////member functions////////////////////////member functions////////////

// ------------ method called once each job just before starting event loop  ------------
void TriggerPrescalesAnalyzer::beginJob()//Everything ROOT related
{
	using namespace std;
	using namespace edm;

	myfile = new TFile("TriggerPrescaleExample.root","RECREATE");
	mytree = new TTree("mytree","Trigger accept information");
	
	trig_vs_pt = fs->make <TH1D>("Trig vs pt", "Trig vs pt ", 100,0,500);
	
	mytree->Branch("jet_pt",&jet_pt);
}




// ------------ method called when starting to processes a run  ------------
void TriggerPrescalesAnalyzer::beginRun(edm::Run const& iRun, edm::EventSetup const& iSetup)//Just what I know it has to be here, otherwise, to beginJob
//--------------------------------------------------------------------------
{
	using namespace std;
  using namespace edm;


  //If the hltConfig can be initialized, then the below is an example of
  //how to extract the config information for the trigger from the 
  //so-called provenance.

  // The trigger configuration can change from 
  // run to run (during the run is the same),
  // so it needs to be called here.

  ///   "init" return value indicates whether intitialisation has succeeded
  ///   "changed" parameter indicates whether the config has actually changed

  bool changed(true);
  if (hltConfig_.init(iRun,iSetup,processName_,changed)) {
    if (changed) {
      // check if trigger name in (new) config
      if (triggerName_!="@") { // "@" means: analyze all triggers in config
	const unsigned int n(hltConfig_.size());
	const unsigned int triggerIndex(hltConfig_.triggerIndex(triggerName_));
	if (triggerIndex>=n) {
	  cout << "HLTEventAnalyzerAOD::analyze:"
	       << " TriggerName " << triggerName_ 
	       << " not available in (new) config!" << endl;
	  cout << "Available TriggerNames are: " << endl;
	  hltConfig_.dump("Triggers");
	}	
      }	
      }	
  } else {
    cout << "HLTEventAnalyzerAOD::analyze:"
	 << " config extraction failure with process name "
	 << processName_ << endl;
	 
	 
  }     
  hltConfig_.dump("Triggers"); 

}//------------------- beginRun()




// ------------ method called for each event  ------------------------------
void TriggerPrescalesAnalyzer::analyze(const edm::Event& iEvent, const edm::EventSetup& iSetup)//2 examples
//--------------------------------------------------------------------------
{
   using namespace edm;
   using namespace std;
   
  
//Declare the handle (container) to store trigger objects.    
   // InputTag trigEventTag("hltTriggerSummaryAOD","","HLT"); //make sure have correct process on MC -> HLT
	//data process=HLT, MC depends, Spring11 is REDIGI311X
	
	//iEvent.getByLabel(triggerEventTag_, triggerEventHandle_);
	
	iEvent.getByLabel(triggerResultsTag_,triggerResultsHandle_);
	
   if (!triggerResultsHandle_.isValid()) {
     cout << "HLTEventAnalyzerAOD::analyze: Error in getting TriggerResults product from Event!" << endl;
     return;
   }
	assert(triggerResultsHandle_->size()==hltConfig_.size());
	
	if (!checkTriggerPass(iEvent, triggerName_)){return;}   	 
	cout<<"*******************************************************************Hey I passed the trigger"<<endl;
//Declare the handle (container) to store jets.	
  // Handle<reco::PFJetCollection> myjets;
  Handle<reco::CaloJetCollection> myjets;
   iEvent.getByLabel(jetInput_, myjets);
   analyzeJets(iEvent,myjets);

   mytree->Fill(); //Now, the information is stored.
   
   

  return;

}//---------------------------analyze()


void TriggerPrescalesAnalyzer::analyzeJets(const edm::Event& iEvent, const edm::Handle<reco::CaloJetCollection> &jets)
{
	numjet = 0;
	jet_pt.clear();
	 if(jets.isValid()){
     // get the number of jets in the event
     numjet=(*jets).size();
        for (reco::CaloJetCollection::const_iterator itjet=jets->begin(); itjet!=jets->end(); ++itjet){
    
	    jet_pt.push_back(itjet->pt());

	    std::cout<<"Jet pT "<<itjet->pt()<<" -- Px "<<itjet->px()<<" -- Px "<<itjet->py()<<" -- Pz "<<itjet->pz()<<std::endl;
 	    
        }
        
        trig_vs_pt->Fill(*std::max_element(jet_pt.begin(), jet_pt.end()));
		//We can know the first element of the vector with: jet_pt.front()
}
}//---------------------------analyzeJets()

//void TriggerPrescalesAnalyzer::analyzeJets(const edm::Event& iEvent, const edm::Handle<reco::PFJetCollection> &jets)
//{
	//numjet = 0;
	//jet_pt.clear();
	 //if(jets.isValid()){
     //// get the number of jets in the event
     //numjet=(*jets).size();
     ////int myidx = 0;
        //for (reco::PFJetCollection::const_iterator itjet=jets->begin(); itjet!=jets->end(); ++itjet){
	    
	    //jet_pt.push_back(itjet->pt());

	    //std::cout<<"Jet pT "<<itjet->pt()<<" -- Px "<<itjet->px()<<" -- Px "<<itjet->py()<<" -- Pz "<<itjet->pz()<<std::endl;
	    ////if (myidx==0) {trig_vs_pt->Fill(itjet->pt());}
        ////myidx++;    	    
        //}
        
        ////trig_vs_pt->Fill(*std::max_element(jet_pt.begin(), jet_pt.end()));
        ////std::cout<<"Maximum value: "<<*std::max_element(jet_pt.begin(), jet_pt.end())<<"First value: "<<jet_pt.front()<<std::endl;
        
        ////if(*std::max_element(jet_pt.begin(), jet_pt.end()) != jet_pt.front()){std::cout<<"###########"<<std::endl<<"###########"<<std::endl<<"###########"<<std::endl<<"Look at me"<<std::endl;}

//}
//}//---------------------------analyzeJets()




bool TriggerPrescalesAnalyzer::checkTriggerPass(const edm::Event& iEvent, const std::string& triggerName)//The method i need to make, take the maximun of the jet pT
{
	
  const unsigned int triggerIndex(hltConfig_.triggerIndex(triggerName));//Get the trigger index for the current trigger
  assert(triggerIndex==iEvent.triggerNames(*triggerResultsHandle_).triggerIndex(triggerName));//check that the trigger in the event and in the configuration agree
  
  //std::cout<<"Currently analyzing trigger "<<triggerName<<std::endl;
	bool theDecision = triggerResultsHandle_->accept(triggerIndex);
    std::cout<<"the decision or accept: "<<theDecision<<std::endl;	
    std::cout<<"was run? "<<triggerResultsHandle_->wasrun(triggerIndex)<<std::endl;
    std::cout<<"error? "<<triggerResultsHandle_->error(triggerIndex)<<std::endl;
    

return theDecision;	
}//---------------------------checkTriggerPass()




// ------------ method called when ending the processing of a run  ------------
void TriggerPrescalesAnalyzer::endRun(edm::Run const&, edm::EventSetup const&)//Just what I know it has to be here, otherwise, to endJob --- Empty for now
{	
	
}




// ------------ method called once each job just after ending the event loop  ------------
void 
TriggerPrescalesAnalyzer::endJob() //Everything ROOT related
{
	myfile->Write();
}//---------------------------endJob()




















//NOT USED HERE 

// ------------ method called when starting to processes a luminosity block  ------------
void 
TriggerPrescalesAnalyzer::beginLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&)
{
	
}//---------------------------beginLuminosityBlock()

// ------------ method called when ending the processing of a luminosity block  ------------
void 
TriggerPrescalesAnalyzer::endLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&)
{
	
}//---------------------------endLuminosityBlock

// ------------ method fills 'descriptions' with the allowed parameters for the module  ------------
void
TriggerPrescalesAnalyzer::fillDescriptions(edm::ConfigurationDescriptions& descriptions) {
  //The following says we do not know what parameters are allowed so do no validation
  // Please change this to state exactly what you do use, even if it is no parameters
  edm::ParameterSetDescription desc;
  desc.setUnknown();
  descriptions.addDefault(desc);
}//---------------------------fillDescriptions()

//define this as a plug-in
DEFINE_FWK_MODULE(TriggerPrescalesAnalyzer);
